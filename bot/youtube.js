const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');
const axios = require('axios');

const execPromise = promisify(exec);

class YouTubeDownloader {
  constructor() {
    this.downloadDir = path.join(__dirname, '../downloads');
    if (!fs.existsSync(this.downloadDir)) {
      fs.mkdirSync(this.downloadDir, { recursive: true });
    }
    
    const homeDir = require('os').homedir();
    const customYtDlp = path.join(homeDir, '.local', 'bin', 'yt-dlp');
    this.ytDlpBin = fs.existsSync(customYtDlp) ? customYtDlp : 'yt-dlp';
    
    this.fallbackApiUrl = process.env.YOUTUBE_FALLBACK_API || null;
    if (this.fallbackApiUrl) {
      console.log(`üîÑ Fallback API enabled: ${this.fallbackApiUrl}`);
    }
    
    this.cookiesPath = null;
    this.initializeCookies();
  }

  convertJsonToNetscape(jsonCookies) {
    try {
      const cookies = typeof jsonCookies === 'string' ? JSON.parse(jsonCookies) : jsonCookies;
      
      let netscapeCookies = '# Netscape HTTP Cookie File\n';
      netscapeCookies += '# This file was generated by bot/youtube.js\n';
      netscapeCookies += '# Edit at your own risk.\n\n';
      
      cookies.forEach(cookie => {
        const domain = cookie.domain || '.youtube.com';
        const flag = domain.startsWith('.') ? 'TRUE' : 'FALSE';
        const path = cookie.path || '/';
        const secure = cookie.secure ? 'TRUE' : 'FALSE';
        const expiration = cookie.expirationDate || cookie.expires || Math.floor(Date.now() / 1000) + (365 * 24 * 60 * 60);
        const name = cookie.name;
        const value = cookie.value;
        
        netscapeCookies += `${domain}\t${flag}\t${path}\t${secure}\t${expiration}\t${name}\t${value}\n`;
      });
      
      return netscapeCookies;
    } catch (error) {
      console.error('‚ùå Failed to convert JSON cookies to Netscape format:', error.message);
      return null;
    }
  }

  initializeCookies() {
    const cookiesFile = path.join(__dirname, '../cookies.txt');
    const cookiesJsonFile = path.join(__dirname, '../cookies.json');
    
    if (fs.existsSync(cookiesFile)) {
      this.cookiesPath = cookiesFile;
      console.log('‚úÖ Using cookies from cookies.txt file (Netscape format)');
    } else if (fs.existsSync(cookiesJsonFile)) {
      try {
        const jsonData = fs.readFileSync(cookiesJsonFile, 'utf8');
        const netscapeCookies = this.convertJsonToNetscape(jsonData);
        
        if (netscapeCookies) {
          const tempCookiesPath = path.join(this.downloadDir, 'temp_cookies.txt');
          fs.writeFileSync(tempCookiesPath, netscapeCookies);
          this.cookiesPath = tempCookiesPath;
          console.log('‚úÖ Using cookies from cookies.json file (converted to Netscape format)');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to process cookies.json:', error.message);
      }
    } else if (process.env.YOUTUBE_COOKIES) {
      try {
        const netscapeCookies = this.convertJsonToNetscape(process.env.YOUTUBE_COOKIES);
        
        if (netscapeCookies) {
          const tempCookiesPath = path.join(this.downloadDir, 'temp_cookies.txt');
          fs.writeFileSync(tempCookiesPath, netscapeCookies);
          this.cookiesPath = tempCookiesPath;
          console.log('‚úÖ Using cookies from YOUTUBE_COOKIES environment variable (converted to Netscape format)');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Failed to write cookies from env var:', error.message);
      }
    } else {
      console.warn('‚ö†Ô∏è No YouTube cookies found. Some videos may fail due to bot detection.');
      console.warn('   Add cookies.txt/cookies.json file or set YOUTUBE_COOKIES environment variable');
    }
  }

  getCookiesArg() {
    if (this.cookiesPath) {
      return `--cookies "${this.cookiesPath}"`;
    }
    return '';
  }

  async getVideoInfo(videoId) {
    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const cookiesArg = this.getCookiesArg();
      
      const command = cookiesArg 
        ? `${this.ytDlpBin} ${cookiesArg} --dump-json "${url}"`
        : `${this.ytDlpBin} --extractor-args "youtube:player_client=android" --dump-json "${url}"`;
      
      const { stdout } = await execPromise(command, { maxBuffer: 10 * 1024 * 1024 });
      
      const info = JSON.parse(stdout);
      
      return {
        title: info.title || 'Unknown',
        duration: info.duration || 0,
        author: info.uploader || info.channel || 'Unknown'
      };
    } catch (error) {
      throw new Error(`Failed to get video info: ${error.message}`);
    }
  }

  async downloadAudio(videoId) {
    const audioPath = path.join(this.downloadDir, `${videoId}_audio.mp3`);

    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const cookiesArg = this.getCookiesArg();
      
      console.log(`üì• Downloading audio with yt-dlp...`);
      
      const command = cookiesArg
        ? `${this.ytDlpBin} ${cookiesArg} -f "bestaudio/best" --extract-audio --audio-format mp3 --audio-quality 128K -o "${audioPath.replace('.mp3', '.%(ext)s')}" "${url}"`
        : `${this.ytDlpBin} --extractor-args "youtube:player_client=android" -f "bestaudio/best" --extract-audio --audio-format mp3 --audio-quality 128K -o "${audioPath.replace('.mp3', '.%(ext)s')}" "${url}"`;
      
      await execPromise(command, { 
        maxBuffer: 50 * 1024 * 1024,
        timeout: 180000
      });

      if (fs.existsSync(audioPath)) {
        console.log(`‚úÖ Audio downloaded: ${audioPath}`);
        return audioPath;
      } else {
        throw new Error('Audio file was not created');
      }
    } catch (error) {
      this.cleanupFile(audioPath);
      throw new Error(`Audio download failed: ${error.message}`);
    }
  }

  async downloadVideo(videoId) {
    const videoPath = path.join(this.downloadDir, `${videoId}_video.mp4`);

    try {
      const url = `https://www.youtube.com/watch?v=${videoId}`;
      const cookiesArg = this.getCookiesArg();
      
      console.log(`üì• Downloading video with yt-dlp...`);
      
      const command = cookiesArg
        ? `${this.ytDlpBin} ${cookiesArg} -f "bv*[height<=480][filesize<45M]+ba[filesize<10M]/b[height<=480][filesize<48M]/bv*[height<=360]+ba/b[height<=360]/worst" --merge-output-format mp4 -o "${videoPath}" "${url}"`
        : `${this.ytDlpBin} --extractor-args "youtube:player_client=android" -f "bv*[height<=480][filesize<45M]+ba[filesize<10M]/b[height<=480][filesize<48M]/bv*[height<=360]+ba/b[height<=360]/worst" --merge-output-format mp4 -o "${videoPath}" "${url}"`;
      
      await execPromise(command, { 
        maxBuffer: 100 * 1024 * 1024,
        timeout: 300000
      });

      if (fs.existsSync(videoPath)) {
        const stats = fs.statSync(videoPath);
        const fileSizeMB = stats.size / (1024 * 1024);
        
        if (fileSizeMB > 48) {
          this.cleanupFile(videoPath);
          throw new Error(`Video too large (${fileSizeMB.toFixed(1)}MB). Telegram limit is 50MB.`);
        }
        
        console.log(`‚úÖ Video downloaded: ${videoPath} (${fileSizeMB.toFixed(1)}MB)`);
        return videoPath;
      } else {
        throw new Error('Video file was not created');
      }
    } catch (error) {
      this.cleanupFile(videoPath);
      throw new Error(`Video download failed: ${error.message}`);
    }
  }

  async download(videoId) {
    try {
      console.log(`üì• Processing video ${videoId}...`);
      
      const info = await this.getVideoInfo(videoId);
      console.log(`üìù Video: ${info.title} by ${info.author}`);
      
      console.log(`üéµ Starting audio download...`);
      const audioPath = await this.downloadAudio(videoId);
      
      console.log(`üé¨ Starting video download...`);
      const videoPath = await this.downloadVideo(videoId);
      
      return {
        title: info.title,
        duration: info.duration,
        author: info.author,
        audioPath,
        videoPath
      };
    } catch (error) {
      throw new Error(`Download failed: ${error.message}`);
    }
  }

  async cleanup(audioPath, videoPath) {
    this.cleanupFile(audioPath);
    this.cleanupFile(videoPath);
  }

  cleanupFile(filePath) {
    try {
      if (fs.existsSync(filePath)) {
        fs.unlinkSync(filePath);
      }
    } catch (error) {
      console.error(`Failed to cleanup file ${filePath}:`, error);
    }
  }
}

module.exports = new YouTubeDownloader();
